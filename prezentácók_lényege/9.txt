A PowerShell objektum orientált
A csovekben objektumok mennek.
Lásd powershell_parancsok.txt
Profile:Dokumentumok\WindowsPowerShell könyvtárban:
• Microsoft.PowerShell_profile.ps1
• profile.ps1 Ezt csak az ISE hajtja végre

egy sorba több parancs írható, ; az elválasztó
változók:
$név=érték

```
$foo="bar"
$baz="foobar"
Write-Host $foo ; Write-Host $baz
```

fontosabb tipusok:
[int] (32-bit)
[byte] (8-bit)
[boolean] $false, $true
[char]
[string]
[single] IEEE 754 32-bit
[double] IEEE 754 64-bit
[datetime]
az összes .net tipus használható
```
$List = New-Object System.Collections.Generic.List[System.String]
$List.Add("asd")
echo $List[0]
[int] $d=6.2e-4
echo $d #0 lesz mert az int levágra
$s1=[string] [char] 65
echo $s1 # A
```
Ha nem jelölünk semmit, az értelmező eldönti a típusát mint pythonban
• Get-variable alma –scope 0 # aktuális környezet
• Get-variable alma –scope 1 # szülő környezet
• Get-variable alma –scope 2 # nagyszülő környezet

```
$foo="bar"

function masodik {
$foo="fizbuz"
	Write-Host $foo
	Write-Host  (Get-variable foo -scope 1).Value
	Write-Host  (Get-variable foo -scope 2).Value
}

function elso {
$foo="baz"
masodik
}
elso
```
kimenet:
fizbuz
baz
bar

meglehet adni kézzel is a scope-ot
$[scope:]név 
ez lehet
$global:x=5 #globálisan (a scipten kivűl is)
$script:y=6 #az egész scriptben
$local:z="MTK” #ez az alap
$env:Path += „;d:\tmp” #környezeti változó

muveletek:
+,-,*,/,%
értékadás:
=, +=, -=, *=, /=, %=
++, --
Bitműveletek:
-band,-bor,-bxor,-bnot,-shl,-shr


• Bármely statikus tulajdonság, metódus elérés operátora a ::
[math]::pi
[math]::sin(2)
[system.convert]::toint32(„32”)

Változó behelyettesítés
$a="alma”
• "$afa” # eredmény üres
• "${a}fa” # eredmény: almafa
• "piros$a”
#pirosalma
• A $ karakter semlegesítése: `
• "`$a változó értéke: $a”
• Reguláris kifejezésben a \ karakter használandó semlegesítésre!
• Parancs behelyettesítés forma külön nincs!
• $könyvtárlista=dir
A "” között lévő szövegben lévő változó behelyettesítésre
kerül az '’ közötti nem.

@” …több sor is
lehet… ”@

$tömb="alma","körte","barack”
– Teljes változat: $tömb=@(”alma”,”körte”,”barack”)
$tömb[1] # körte
$tömb[1..2]
$tömb[2]=@(2,3,4); echo $tömb[2][1] # 3
$tömb.Length

#sajnos nem kötelező a zárójel
1,2,3,4 –contains 3 # true
1,2,3,4 -notcontains 3 # false

-eq, -ne Eredmény az összes elem ami egyenlő, (nem egyenlő) adott
értékkel
• 1,2,3,4 –ne 3
# 1,2,4
-lt, -gt -le, -ge -join, -split, -csplit

$atömb=@{„kulcs”=„érték”; …}
• $at=@{a=4;b=5} # Elemek között a ; !!!!!!
• Elem elérés: $at[a] vagy $at.a
• Elem értékadás: $at[a]=10
• Új elem hozzáadás: $at+=@{c=11}


if (kif) {utasítás} [elseif (kif1) {utasítás}] else {utasítás}
hasonlóan super syntaxis mint bash-ben
-eq, -ne,-gt,-lt, -le, -ge
• -not, -and, -or,-xor logikai tagadás, és, vagy
• Szövegnél: -ceq, Kis, nagybetű különböző, -ieq nem különböző,
• -like *,?,[ab.] karakterek, -match reg. kif. használat
```
if ( 5 -eq 5){
	Write-Host "asd"
}
```
```
$a=Read-Host -prompt "Írja be a kedvenc gyümölcsét "
switch ($a)
{
	"alma"		{ "a értéke: "+$a } # write-output röv.
	"barack"	{ "a értéke: "+$a }
	"szőlő"		{ "a értéke: "+$a }
	"szilva"	{ "a értéke: "+$a }
	"körte"		{ "a értéke: "+$a }
	default		{ "a ismeretlen számomra: "+$a}
}
```
```
for($i=0;$i –lt 5;$i++) {echo $i}
```
```
$t=2,3,4,5
foreach($i in $t) { #lehet új sorba ha valaki azt akarja
	write-host $i
}
```
a ` az ujsort escape-eli
foreach-object olyan mint az awk
```
get-process|foreach-object `
-begin { Write-Host "Elkezdtem a Get-Process feldolgozást!" } `
-process { write-host $_.name -foreground green } `
-end { Write-Host "Befejeztem a Get-Process feldolgozást!" }
```
```
$a=5
while ($a -gt 0)
{
write-host $a
$a--
}
```
```
do {
"Egyszer belépek a ciklusba biztosan!"
write-host $a
$a--
} while ($a -gt 0)
```
```
$a=0
do {
"Egyszer belépek a ciklusba biztosan!"
write-host $a
$a++
} until ($a -gt 3)
```

ezt csak ithagyom
https://github.com/BenzoXdev/Fuck-Windows-Security
